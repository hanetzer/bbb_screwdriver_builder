Index: lede/target/linux/omap/patches-4.4/150-use-beagleboard-dts-files.patch
===================================================================
--- /dev/null
+++ lede/target/linux/omap/patches-4.4/150-use-beagleboard-dts-files.patch
@@ -0,0 +1,1083 @@
+Index: linux-4.4.13/arch/arm/boot/dts/am335x-bone-common.dtsi
+===================================================================
+--- linux-4.4.13.orig/arch/arm/boot/dts/am335x-bone-common.dtsi
++++ linux-4.4.13/arch/arm/boot/dts/am335x-bone-common.dtsi
+@@ -19,20 +19,21 @@
+ 	};
+ 
+ 	leds {
+-		pinctrl-names = "default";
+-		pinctrl-0 = <&user_leds_s0>;
++		pinctrl-names = "default", "sleep";
++		pinctrl-0 = <&user_leds_default>;
++		pinctrl-1 = <&user_leds_sleep>;
+ 
+ 		compatible = "gpio-leds";
+ 
+ 		led@2 {
+-			label = "beaglebone:green:heartbeat";
++			label = "beaglebone:green:usr0";
+ 			gpios = <&gpio1 21 GPIO_ACTIVE_HIGH>;
+ 			linux,default-trigger = "heartbeat";
+ 			default-state = "off";
+ 		};
+ 
+ 		led@3 {
+-			label = "beaglebone:green:mmc0";
++			label = "beaglebone:green:usr1";
+ 			gpios = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+ 			linux,default-trigger = "mmc0";
+ 			default-state = "off";
+@@ -62,117 +63,121 @@
+ };
+ 
+ &am33xx_pinmux {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&clkout2_pin>;
+-
+-	user_leds_s0: user_leds_s0 {
++	user_leds_default: user_leds_default {
+ 		pinctrl-single,pins = <
+-			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a5.gpio1_21 */
+-			0x58 (PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a6.gpio1_22 */
+-			0x5c (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a7.gpio1_23 */
+-			0x60 (PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a8.gpio1_24 */
++			AM33XX_IOPAD(0x854, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a5.gpio1_21 */
++			AM33XX_IOPAD(0x858, PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a6.gpio1_22 */
++			AM33XX_IOPAD(0x85c, PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a7.gpio1_23 */
++			AM33XX_IOPAD(0x860, PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a8.gpio1_24 */
+ 		>;
+ 	};
+ 
+-	i2c0_pins: pinmux_i2c0_pins {
++	user_leds_sleep: user_leds_sleep {
+ 		pinctrl-single,pins = <
+-			0x188 (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+-			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
++			AM33XX_IOPAD(0x854, PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a5.gpio1_21 */
++			AM33XX_IOPAD(0x858, PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a6.gpio1_22 */
++			AM33XX_IOPAD(0x85c, PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a7.gpio1_23 */
++			AM33XX_IOPAD(0x860, PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a8.gpio1_24 */
+ 		>;
+ 	};
+ 
+-	i2c2_pins: pinmux_i2c2_pins {
++	i2c0_pins: pinmux_i2c0_pins {
+ 		pinctrl-single,pins = <
+-			0x178 (PIN_INPUT_PULLUP | MUX_MODE3)	/* uart1_ctsn.i2c2_sda */
+-			0x17c (PIN_INPUT_PULLUP | MUX_MODE3)	/* uart1_rtsn.i2c2_scl */
++			AM33XX_IOPAD(0x988, PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
++			AM33XX_IOPAD(0x98c, PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+ 		>;
+ 	};
+ 
+-	uart0_pins: pinmux_uart0_pins {
++	i2c2_pins: pinmux_i2c2_pins {
+ 		pinctrl-single,pins = <
+-			0x170 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+-			0x174 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
++			AM33XX_IOPAD(0x978, PIN_INPUT_PULLUP | MUX_MODE3)	/* uart1_ctsn.i2c2_sda */
++			AM33XX_IOPAD(0x97c, PIN_INPUT_PULLUP | MUX_MODE3)	/* uart1_rtsn.i2c2_scl */
+ 		>;
+ 	};
+ 
+-	clkout2_pin: pinmux_clkout2_pin {
++	uart0_pins: pinmux_uart0_pins {
+ 		pinctrl-single,pins = <
+-			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
++			AM33XX_IOPAD(0x970, PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
++			AM33XX_IOPAD(0x974, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
+ 		>;
+ 	};
+ 
+ 	cpsw_default: cpsw_default {
+ 		pinctrl-single,pins = <
+ 			/* Slave 1 */
+-			0x110 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxerr.mii1_rxerr */
+-			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txen.mii1_txen */
+-			0x118 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxdv.mii1_rxdv */
+-			0x11c (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd3.mii1_txd3 */
+-			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd2.mii1_txd2 */
+-			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd1.mii1_txd1 */
+-			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd0.mii1_txd0 */
+-			0x12c (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_txclk.mii1_txclk */
+-			0x130 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxclk.mii1_rxclk */
+-			0x134 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd3.mii1_rxd3 */
+-			0x138 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd2.mii1_rxd2 */
+-			0x13c (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd1.mii1_rxd1 */
+-			0x140 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd0.mii1_rxd0 */
++			0x108 (PIN_INPUT | MUX_MODE0)		/* mii1_col.mii1_col */
++			0x10c (PIN_INPUT | MUX_MODE0)		/* mii1_crs.mii1_crs */
++			AM33XX_IOPAD(0x910, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxerr.mii1_rxerr */
++			AM33XX_IOPAD(0x914, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txen.mii1_txen */
++			AM33XX_IOPAD(0x918, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxdv.mii1_rxdv */
++			AM33XX_IOPAD(0x91c, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd3.mii1_txd3 */
++			AM33XX_IOPAD(0x920, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd2.mii1_txd2 */
++			AM33XX_IOPAD(0x924, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd1.mii1_txd1 */
++			AM33XX_IOPAD(0x928, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* mii1_txd0.mii1_txd0 */
++			AM33XX_IOPAD(0x92c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_txclk.mii1_txclk */
++			AM33XX_IOPAD(0x930, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxclk.mii1_rxclk */
++			AM33XX_IOPAD(0x934, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd3.mii1_rxd3 */
++			AM33XX_IOPAD(0x938, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd2.mii1_rxd2 */
++			AM33XX_IOPAD(0x93c, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd1.mii1_rxd1 */
++			AM33XX_IOPAD(0x940, PIN_INPUT_PULLUP | MUX_MODE0)	/* mii1_rxd0.mii1_rxd0 */
+ 		>;
+ 	};
+ 
+ 	cpsw_sleep: cpsw_sleep {
+ 		pinctrl-single,pins = <
+ 			/* Slave 1 reset value */
+-			0x110 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x114 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x11c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x120 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x124 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x128 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x12c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x134 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x138 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE7)
++			0x108 (PIN_INPUT_PULLDOWN | MUX_MODE7)
++			0x10c (PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x910, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x914, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x918, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x91c, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x920, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x924, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x928, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x92c, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x930, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x934, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x938, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x93c, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x940, PIN_INPUT_PULLDOWN | MUX_MODE7)
+ 		>;
+ 	};
+ 
+ 	davinci_mdio_default: davinci_mdio_default {
+ 		pinctrl-single,pins = <
+ 			/* MDIO */
+-			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+-			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
++			AM33XX_IOPAD(0x948, PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
++			AM33XX_IOPAD(0x94c, PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+ 		>;
+ 	};
+ 
+ 	davinci_mdio_sleep: davinci_mdio_sleep {
+ 		pinctrl-single,pins = <
+ 			/* MDIO reset value */
+-			0x148 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+-			0x14c (PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x948, PIN_INPUT_PULLDOWN | MUX_MODE7)
++			AM33XX_IOPAD(0x94c, PIN_INPUT_PULLDOWN | MUX_MODE7)
+ 		>;
+ 	};
+ 
+ 	mmc1_pins: pinmux_mmc1_pins {
+ 		pinctrl-single,pins = <
+-			0x160 (PIN_INPUT | MUX_MODE7) /* GPIO0_6 */
++			AM33XX_IOPAD(0x960, PIN_INPUT | MUX_MODE7) /* GPIO0_6 */
+ 		>;
+ 	};
+ 
+ 	emmc_pins: pinmux_emmc_pins {
+ 		pinctrl-single,pins = <
+-			0x80 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
+-			0x84 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
+-			0x00 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad0.mmc1_dat0 */
+-			0x04 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad1.mmc1_dat1 */
+-			0x08 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad2.mmc1_dat2 */
+-			0x0c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad3.mmc1_dat3 */
+-			0x10 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad4.mmc1_dat4 */
+-			0x14 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad5.mmc1_dat5 */
+-			0x18 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad6.mmc1_dat6 */
+-			0x1c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad7.mmc1_dat7 */
++			AM33XX_IOPAD(0x880, PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
++			AM33XX_IOPAD(0x884, PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
++			AM33XX_IOPAD(0x800, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad0.mmc1_dat0 */
++			AM33XX_IOPAD(0x804, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad1.mmc1_dat1 */
++			AM33XX_IOPAD(0x808, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad2.mmc1_dat2 */
++			AM33XX_IOPAD(0x80c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad3.mmc1_dat3 */
++			AM33XX_IOPAD(0x810, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad4.mmc1_dat4 */
++			AM33XX_IOPAD(0x814, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad5.mmc1_dat5 */
++			AM33XX_IOPAD(0x818, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad6.mmc1_dat6 */
++			AM33XX_IOPAD(0x81c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad7.mmc1_dat7 */
+ 		>;
+ 	};
+ };
+@@ -286,55 +291,6 @@
+ };
+ 
+ 
+-&i2c2 {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&i2c2_pins>;
+-
+-	status = "okay";
+-	clock-frequency = <100000>;
+-
+-	cape_eeprom0: cape_eeprom0@54 {
+-		compatible = "at,24c256";
+-		reg = <0x54>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		cape0_data: cape_data@0 {
+-			reg = <0 0x100>;
+-		};
+-	};
+-
+-	cape_eeprom1: cape_eeprom1@55 {
+-		compatible = "at,24c256";
+-		reg = <0x55>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		cape1_data: cape_data@0 {
+-			reg = <0 0x100>;
+-		};
+-	};
+-
+-	cape_eeprom2: cape_eeprom2@56 {
+-		compatible = "at,24c256";
+-		reg = <0x56>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		cape2_data: cape_data@0 {
+-			reg = <0 0x100>;
+-		};
+-	};
+-
+-	cape_eeprom3: cape_eeprom3@57 {
+-		compatible = "at,24c256";
+-		reg = <0x57>;
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		cape3_data: cape_data@0 {
+-			reg = <0 0x100>;
+-		};
+-	};
+-};
+-
+-
+ /include/ "tps65217.dtsi"
+ 
+ &tps {
+@@ -357,6 +313,9 @@
+ 	 */
+ 	ti,pmic-shutdown-controller;
+ 
++	interrupt-parent = <&intc>;
++	interrupts = <7>;	/* NNMI */
++
+ 	regulators {
+ 		dcdc1_reg: regulator@0 {
+ 			regulator-name = "vdds_dpr";
+@@ -367,7 +326,7 @@
+ 			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+ 			regulator-name = "vdd_mpu";
+ 			regulator-min-microvolt = <925000>;
+-			regulator-max-microvolt = <1325000>;
++			regulator-max-microvolt = <1351500>;
+ 			regulator-boot-on;
+ 			regulator-always-on;
+ 		};
+@@ -408,15 +367,11 @@
+ 	phy-mode = "mii";
+ };
+ 
+-&cpsw_emac1 {
+-	phy_id = <&davinci_mdio>, <1>;
+-	phy-mode = "mii";
+-};
+-
+ &mac {
+ 	pinctrl-names = "default", "sleep";
+ 	pinctrl-0 = <&cpsw_default>;
+ 	pinctrl-1 = <&cpsw_sleep>;
++	slaves = <1>;
+ 	status = "okay";
+ };
+ 
+@@ -443,6 +398,18 @@
+ 	status = "okay";
+ };
+ 
++&wkup_m3_ipc {
++	ti,scale-data-fw = "am335x-bone-scale-data.bin";
++};
++
++&rtc {
++	system-power-controller;
++};
++
++&sgx {
++	status = "okay";
++};
++
+ /* the cape manager */
+ / {
+ 	bone_capemgr {
+Index: linux-4.4.13/arch/arm/boot/dts/am335x-bone.dts
+===================================================================
+--- linux-4.4.13.orig/arch/arm/boot/dts/am335x-bone.dts
++++ linux-4.4.13/arch/arm/boot/dts/am335x-bone.dts
+@@ -9,6 +9,7 @@
+ 
+ #include "am33xx.dtsi"
+ #include "am335x-bone-common.dtsi"
++#include "am33xx-overlay-edma-fix.dtsi"
+ 
+ / {
+ 	model = "TI AM335x BeagleBone";
+@@ -24,3 +25,7 @@
+ &mmc1 {
+ 	vmmc-supply = <&ldo3_reg>;
+ };
++
++&sgx {
++	status = "okay";
++};
+Index: linux-4.4.13/arch/arm/boot/dts/am335x-boneblack.dts
+===================================================================
+--- linux-4.4.13.orig/arch/arm/boot/dts/am335x-boneblack.dts
++++ linux-4.4.13/arch/arm/boot/dts/am335x-boneblack.dts
+@@ -9,6 +9,9 @@
+ 
+ #include "am33xx.dtsi"
+ #include "am335x-bone-common.dtsi"
++#include "am33xx-overlay-edma-fix.dtsi"
++#include <dt-bindings/display/tda998x.h>
++/* #include "am335x-bone-jtag.dtsi" */
+ 
+ / {
+ 	model = "TI AM335x BeagleBone Black";
+@@ -33,35 +36,56 @@
+ 	status = "okay";
+ };
+ 
++&cpu0_opp_table {
++	/*
++	 * All PG 2.0 silicon may not support 1GHz but some of the early
++	 * BeagleBone Blacks have PG 2.0 silicon which is guaranteed
++	 * to support 1GHz OPP so enable it for PG 2.0 on this board.
++	 */
++	oppnitro@1000000000 {
++		opp-supported-hw = <0x06 0x0100>;
++	};
++};
++
+ &am33xx_pinmux {
+ 	nxp_hdmi_bonelt_pins: nxp_hdmi_bonelt_pins {
+ 		pinctrl-single,pins = <
+-			0x1b0 0x03      /* xdma_event_intr0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT */
+-			0xa0 0x08       /* lcd_data0.lcd_data0, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xa4 0x08       /* lcd_data1.lcd_data1, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xa8 0x08       /* lcd_data2.lcd_data2, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xac 0x08       /* lcd_data3.lcd_data3, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xb0 0x08       /* lcd_data4.lcd_data4, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xb4 0x08       /* lcd_data5.lcd_data5, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xb8 0x08       /* lcd_data6.lcd_data6, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xbc 0x08       /* lcd_data7.lcd_data7, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xc0 0x08       /* lcd_data8.lcd_data8, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xc4 0x08       /* lcd_data9.lcd_data9, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xc8 0x08       /* lcd_data10.lcd_data10, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xcc 0x08       /* lcd_data11.lcd_data11, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xd0 0x08       /* lcd_data12.lcd_data12, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xd4 0x08       /* lcd_data13.lcd_data13, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xd8 0x08       /* lcd_data14.lcd_data14, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xdc 0x08       /* lcd_data15.lcd_data15, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+-			0xe0 0x00       /* lcd_vsync.lcd_vsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+-			0xe4 0x00       /* lcd_hsync.lcd_hsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+-			0xe8 0x00       /* lcd_pclk.lcd_pclk, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+-			0xec 0x00       /* lcd_ac_bias_en.lcd_ac_bias_en, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
++			AM33XX_IOPAD(0x9b0, PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr0 */
++			AM33XX_IOPAD(0x8a0, PIN_OUTPUT | MUX_MODE0)		/* lcd_data0.lcd_data0 */
++			AM33XX_IOPAD(0x8a4, PIN_OUTPUT | MUX_MODE0)		/* lcd_data1.lcd_data1 */
++			AM33XX_IOPAD(0x8a8, PIN_OUTPUT | MUX_MODE0)		/* lcd_data2.lcd_data2 */
++			AM33XX_IOPAD(0x8ac, PIN_OUTPUT | MUX_MODE0)		/* lcd_data3.lcd_data3 */
++			AM33XX_IOPAD(0x8b0, PIN_OUTPUT | MUX_MODE0)		/* lcd_data4.lcd_data4 */
++			AM33XX_IOPAD(0x8b4, PIN_OUTPUT | MUX_MODE0)		/* lcd_data5.lcd_data5 */
++			AM33XX_IOPAD(0x8b8, PIN_OUTPUT | MUX_MODE0)		/* lcd_data6.lcd_data6 */
++			AM33XX_IOPAD(0x8bc, PIN_OUTPUT | MUX_MODE0)		/* lcd_data7.lcd_data7 */
++			AM33XX_IOPAD(0x8c0, PIN_OUTPUT | MUX_MODE0)		/* lcd_data8.lcd_data8 */
++			AM33XX_IOPAD(0x8c4, PIN_OUTPUT | MUX_MODE0)		/* lcd_data9.lcd_data9 */
++			AM33XX_IOPAD(0x8c8, PIN_OUTPUT | MUX_MODE0)		/* lcd_data10.lcd_data10 */
++			AM33XX_IOPAD(0x8cc, PIN_OUTPUT | MUX_MODE0)		/* lcd_data11.lcd_data11 */
++			AM33XX_IOPAD(0x8d0, PIN_OUTPUT | MUX_MODE0)		/* lcd_data12.lcd_data12 */
++			AM33XX_IOPAD(0x8d4, PIN_OUTPUT | MUX_MODE0)		/* lcd_data13.lcd_data13 */
++			AM33XX_IOPAD(0x8d8, PIN_OUTPUT | MUX_MODE0)		/* lcd_data14.lcd_data14 */
++			AM33XX_IOPAD(0x8dc, PIN_OUTPUT | MUX_MODE0)		/* lcd_data15.lcd_data15 */
++			AM33XX_IOPAD(0x8e0, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* lcd_vsync.lcd_vsync */
++			AM33XX_IOPAD(0x8e4, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* lcd_hsync.lcd_hsync */
++			AM33XX_IOPAD(0x8e8, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* lcd_pclk.lcd_pclk */
++			AM33XX_IOPAD(0x8ec, PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* lcd_ac_bias_en.lcd_ac_bias_en */
+ 		>;
+ 	};
+ 	nxp_hdmi_bonelt_off_pins: nxp_hdmi_bonelt_off_pins {
+ 		pinctrl-single,pins = <
+-			0x1b0 0x03      /* xdma_event_intr0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT */
++			AM33XX_IOPAD(0x9b0, PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr0 */
++		>;
++	};
++
++	mcasp0_pins: mcasp0_pins {
++		pinctrl-single,pins = <
++			AM33XX_IOPAD(0x9ac, PIN_INPUT_PULLUP | MUX_MODE0) /* mcasp0_ahcklx.mcasp0_ahclkx */
++			AM33XX_IOPAD(0x99c, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mcasp0_ahclkr.mcasp0_axr2*/
++			AM33XX_IOPAD(0x994, PIN_OUTPUT_PULLUP | MUX_MODE0) /* mcasp0_fsx.mcasp0_fsx */
++			AM33XX_IOPAD(0x990, PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* mcasp0_aclkx.mcasp0_aclkx */
++			AM33XX_IOPAD(0x86c, PIN_OUTPUT_PULLDOWN | MUX_MODE7) /* gpmc_a11.GPIO1_27 */
+ 		>;
+ 	};
+ };
+@@ -76,21 +100,69 @@
+ };
+ 
+ &i2c0 {
+-	tda19988 {
++	tda19988: tda19988 {
+ 		compatible = "nxp,tda998x";
+ 		reg = <0x70>;
++
+ 		pinctrl-names = "default", "off";
+ 		pinctrl-0 = <&nxp_hdmi_bonelt_pins>;
+ 		pinctrl-1 = <&nxp_hdmi_bonelt_off_pins>;
+ 
+-		port {
+-			hdmi_0: endpoint@0 {
+-				remote-endpoint = <&lcdc_0>;
++		#sound-dai-cells = <0>;
++		audio-ports = <	AFMT_I2S	0x03>;
++
++		ports {
++			port@0 {
++				hdmi_0: endpoint@0 {
++					remote-endpoint = <&lcdc_0>;
++				};
+ 			};
+ 		};
+ 	};
+ };
+ 
+-&rtc {
+-	system-power-controller;
++&mcasp0	{
++	#sound-dai-cells = <0>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&mcasp0_pins>;
++	status = "okay";
++	op-mode = <0>;	/* MCASP_IIS_MODE */
++	tdm-slots = <2>;
++	serial-dir = <	/* 0: INACTIVE, 1: TX, 2: RX */
++			0 0 1 0
++		>;
++	tx-num-evt = <32>;
++	rx-num-evt = <32>;
++};
++
++/ {
++	clk_mcasp0_fixed: clk_mcasp0_fixed {
++		#clock-cells = <0>;
++		compatible = "fixed-clock";
++		clock-frequency = <24576000>;
++	};
++
++	clk_mcasp0: clk_mcasp0 {
++		#clock-cells = <0>;
++		compatible = "gpio-gate-clock";
++		clocks = <&clk_mcasp0_fixed>;
++		enable-gpios = <&gpio1 27 0>; /* BeagleBone Black Clk enable on GPIO1_27 */
++	};
++
++	sound {
++		compatible = "simple-audio-card";
++		simple-audio-card,name = "TI BeagleBone Black";
++		simple-audio-card,format = "i2s";
++		simple-audio-card,bitclock-master = <&dailink0_master>;
++		simple-audio-card,frame-master = <&dailink0_master>;
++
++		dailink0_master: simple-audio-card,cpu {
++			sound-dai = <&mcasp0>;
++			clocks = <&clk_mcasp0>;
++		};
++
++		simple-audio-card,codec {
++			sound-dai = <&tda19988>;
++		};
++	};
+ };
+Index: linux-4.4.13/arch/arm/boot/dts/am33xx.dtsi
+===================================================================
+--- linux-4.4.13.orig/arch/arm/boot/dts/am33xx.dtsi
++++ linux-4.4.13/arch/arm/boot/dts/am33xx.dtsi
+@@ -42,27 +42,101 @@
+ 		#size-cells = <0>;
+ 		cpu@0 {
+ 			compatible = "arm,cortex-a8";
++			enable-method = "ti,am3352";
+ 			device_type = "cpu";
+ 			reg = <0>;
+ 
+-			/*
+-			 * To consider voltage drop between PMIC and SoC,
+-			 * tolerance value is reduced to 2% from 4% and
+-			 * voltage value is increased as a precaution.
+-			 */
+-			operating-points = <
+-				/* kHz    uV */
+-				720000  1285000
+-				600000  1225000
+-				500000  1125000
+-				275000  1125000
+-			>;
+-			voltage-tolerance = <2>; /* 2 percentage */
++			operating-points-v2 = <&cpu0_opp_table>;
++			ti,syscon-efuse = <&scm_conf 0x7fc 0x1fff 0>;
++			ti,syscon-rev = <&scm_conf 0x600>;
+ 
+ 			clocks = <&dpll_mpu_ck>;
+ 			clock-names = "cpu";
+ 
+ 			clock-latency = <300000>; /* From omap-cpufreq driver */
++			cpu-idle-states = <&mpu_gate>;
++		};
++
++		idle-states {
++			mpu_gate: mpu_gate {
++				compatible = "arm,idle-state";
++				entry-latency-us = <40>;
++				exit-latency-us = <90>;
++				min-residency-us = <300>;
++				ti,idle-wkup-m3;
++			};
++		};
++	};
++
++	cpu0_opp_table: opp_table0 {
++		compatible = "operating-points-v2";
++
++		/*
++		 * The three following nodes are marked with opp-suspend
++		 * because the can not be enabled simultaneously on a
++		 * single SoC.
++		 */
++		opp50@300000000 {
++			opp-hz = /bits/ 64 <300000000>;
++			opp-microvolt = <950000 931000 969000>;
++			opp-supported-hw = <0x06 0x0010>;
++			opp-suspend;
++		};
++
++		opp100@275000000 {
++			opp-hz = /bits/ 64 <275000000>;
++			opp-microvolt = <1100000 1078000 1122000>;
++			opp-supported-hw = <0x01 0x00FF>;
++			opp-suspend;
++		};
++
++		opp100@300000000 {
++			opp-hz = /bits/ 64 <300000000>;
++			opp-microvolt = <1100000 1078000 1122000>;
++			opp-supported-hw = <0x06 0x0020>;
++			opp-suspend;
++		};
++
++		opp100@500000000 {
++			opp-hz = /bits/ 64 <500000000>;
++			opp-microvolt = <1100000 1078000 1122000>;
++			opp-supported-hw = <0x01 0xFFFF>;
++		};
++
++		opp100@600000000 {
++			opp-hz = /bits/ 64 <600000000>;
++			opp-microvolt = <1100000 1078000 1122000>;
++			opp-supported-hw = <0x06 0x0040>;
++		};
++
++		opp120@600000000 {
++			opp-hz = /bits/ 64 <600000000>;
++			opp-microvolt = <1200000 1176000 1224000>;
++			opp-supported-hw = <0x01 0xFFFF>;
++		};
++
++		opp120@720000000 {
++			opp-hz = /bits/ 64 <720000000>;
++			opp-microvolt = <1200000 1176000 1224000>;
++			opp-supported-hw = <0x06 0x0080>;
++		};
++
++		oppturbo@720000000 {
++			opp-hz = /bits/ 64 <720000000>;
++			opp-microvolt = <1260000 1234800 1285200>;
++			opp-supported-hw = <0x01 0xFFFF>;
++		};
++
++		oppturbo@800000000 {
++			opp-hz = /bits/ 64 <800000000>;
++			opp-microvolt = <1260000 1234800 1285200>;
++			opp-supported-hw = <0x06 0x0100>;
++		};
++
++		oppnitro@1000000000 {
++			opp-hz = /bits/ 64 <1000000000>;
++			opp-microvolt = <1325000 1298500 1351500>;
++			opp-supported-hw = <0x04 0x0200>;
+ 		};
+ 	};
+ 
+@@ -80,6 +154,7 @@
+ 		mpu {
+ 			compatible = "ti,omap3-mpu";
+ 			ti,hwmods = "mpu";
++			sram = <&ocmcram>;
+ 		};
+ 	};
+ 
+@@ -90,7 +165,7 @@
+ 	 * for the moment, just use a fake OCP bus entry to represent
+ 	 * the whole bus hierarchy.
+ 	 */
+-	ocp {
++	ocp: ocp {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+@@ -161,6 +236,14 @@
+ 					mboxes = <&mailbox &mbox_wkupm3>;
+ 				};
+ 
++				edma_xbar: dma-router@f90 {
++					compatible = "ti,am335x-edma-crossbar";
++					reg = <0xf90 0x40>;
++					#dma-cells = <3>;
++					dma-requests = <32>;
++					dma-masters = <&edma>;
++				};
++
+ 				scm_clockdomains: clockdomains {
+ 				};
+ 			};
+@@ -174,12 +257,50 @@
+ 		};
+ 
+ 		edma: edma@49000000 {
+-			compatible = "ti,edma3";
+-			ti,hwmods = "tpcc", "tptc0", "tptc1", "tptc2";
+-			reg =	<0x49000000 0x10000>,
+-				<0x44e10f90 0x40>;
++			compatible = "ti,edma3-tpcc";
++			ti,hwmods = "tpcc";
++			reg =	<0x49000000 0x10000>;
++			reg-names = "edma3_cc";
+ 			interrupts = <12 13 14>;
+-			#dma-cells = <1>;
++			interrupt-names = "edma3_ccint", "emda3_mperr",
++					  "edma3_ccerrint";
++			dma-requests = <64>;
++			#dma-cells = <2>;
++
++			ti,tptcs = <&edma_tptc0 7>, <&edma_tptc1 5>,
++				   <&edma_tptc2 0>;
++
++			ti,edma-memcpy-channels = <20 21>;
++		};
++
++		edma_tptc0: tptc@49800000 {
++			compatible = "ti,edma3-tptc";
++			ti,hwmods = "tptc0";
++			reg =	<0x49800000 0x100000>;
++			interrupts = <112>;
++			interrupt-names = "edma3_tcerrint";
++		};
++
++		edma_tptc1: tptc@49900000 {
++			compatible = "ti,edma3-tptc";
++			ti,hwmods = "tptc1";
++			reg =	<0x49900000 0x100000>;
++			interrupts = <113>;
++			interrupt-names = "edma3_tcerrint";
++		};
++
++		edma_tptc2: tptc@49a00000 {
++			compatible = "ti,edma3-tptc";
++			ti,hwmods = "tptc2";
++			reg =	<0x49a00000 0x100000>;
++			interrupts = <114>;
++			interrupt-names = "edma3_tcerrint";
++		};
++
++		emif: emif@4c000000 {
++			compatible = "ti,emif-am3352";
++			reg =	<0x4C000000 0x1000>;
++			sram = <&ocmcram>;
+ 		};
+ 
+ 		gpio0: gpio@44e07000 {
+@@ -233,7 +354,7 @@
+ 			reg = <0x44e09000 0x2000>;
+ 			interrupts = <72>;
+ 			status = "disabled";
+-			dmas = <&edma 26>, <&edma 27>;
++			dmas = <&edma 26 0>, <&edma 27 0>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -244,7 +365,7 @@
+ 			reg = <0x48022000 0x2000>;
+ 			interrupts = <73>;
+ 			status = "disabled";
+-			dmas = <&edma 28>, <&edma 29>;
++			dmas = <&edma 28 0>, <&edma 29 0>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -255,7 +376,7 @@
+ 			reg = <0x48024000 0x2000>;
+ 			interrupts = <74>;
+ 			status = "disabled";
+-			dmas = <&edma 30>, <&edma 31>;
++			dmas = <&edma 30 0>, <&edma 31 0>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -322,8 +443,8 @@
+ 			ti,dual-volt;
+ 			ti,needs-special-reset;
+ 			ti,needs-special-hs-handling;
+-			dmas = <&edma 24
+-				&edma 25>;
++			dmas = <&edma_xbar 24 0 0
++				&edma_xbar 25 0 0>;
+ 			dma-names = "tx", "rx";
+ 			interrupts = <64>;
+ 			interrupt-parent = <&intc>;
+@@ -335,8 +456,8 @@
+ 			compatible = "ti,omap4-hsmmc";
+ 			ti,hwmods = "mmc2";
+ 			ti,needs-special-reset;
+-			dmas = <&edma 2
+-				&edma 3>;
++			dmas = <&edma 2 0
++				&edma 3 0>;
+ 			dma-names = "tx", "rx";
+ 			interrupts = <28>;
+ 			interrupt-parent = <&intc>;
+@@ -399,9 +520,18 @@
+ 			ti,mbox-num-users = <4>;
+ 			ti,mbox-num-fifos = <8>;
+ 			mbox_wkupm3: wkup_m3 {
++				ti,mbox-send-noirq;
+ 				ti,mbox-tx = <0 0 0>;
+ 				ti,mbox-rx = <0 0 3>;
+ 			};
++			mbox_pru0: mbox_pru0 {
++				ti,mbox-tx = <2 0 0>;
++				ti,mbox-rx = <3 0 0>;
++			};
++			mbox_pru1: mbox_pru1 {
++				ti,mbox-tx = <4 0 0>;
++				ti,mbox-rx = <5 0 0>;
++			};
+ 		};
+ 
+ 		timer1: timer@44e31000 {
+@@ -474,10 +604,10 @@
+ 			interrupts = <65>;
+ 			ti,spi-num-cs = <2>;
+ 			ti,hwmods = "spi0";
+-			dmas = <&edma 16
+-				&edma 17
+-				&edma 18
+-				&edma 19>;
++			dmas = <&edma 16 0
++				&edma 17 0
++				&edma 18 0
++				&edma 19 0>;
+ 			dma-names = "tx0", "rx0", "tx1", "rx1";
+ 			status = "disabled";
+ 		};
+@@ -490,10 +620,10 @@
+ 			interrupts = <125>;
+ 			ti,spi-num-cs = <2>;
+ 			ti,hwmods = "spi1";
+-			dmas = <&edma 42
+-				&edma 43
+-				&edma 44
+-				&edma 45>;
++			dmas = <&edma 42 0
++				&edma 43 0
++				&edma 44 0
++				&edma 45 0>;
+ 			dma-names = "tx0", "rx0", "tx1", "rx1";
+ 			status = "disabled";
+ 		};
+@@ -643,15 +773,24 @@
+ 				reg = <0x48300100 0x80>;
+ 				interrupts = <31>;
+ 				interrupt-names = "ecap0";
+-				ti,hwmods = "ecap0";
+ 				status = "disabled";
+ 			};
+ 
+-			ehrpwm0: ehrpwm@48300200 {
++			eqep0: eqep@0x48300180 {
++				compatible = "ti,am33xx-eqep";
++				reg = <0x48300180 0x80>;
++				interrupt-parent = <&intc>;
++				interrupts = <79>;
++				ti,hwmods = "eqep0";
++				status = "disabled";
++			};
++
++			ehrpwm0: pwm@48300200 {
+ 				compatible = "ti,am33xx-ehrpwm";
+ 				#pwm-cells = <3>;
+ 				reg = <0x48300200 0x80>;
+-				ti,hwmods = "ehrpwm0";
++				clocks = <&ehrpwm0_tbclk>;
++				clock-names = "tbclk";
+ 				status = "disabled";
+ 			};
+ 		};
+@@ -673,15 +812,25 @@
+ 				reg = <0x48302100 0x80>;
+ 				interrupts = <47>;
+ 				interrupt-names = "ecap1";
+-				ti,hwmods = "ecap1";
+ 				status = "disabled";
+ 			};
+ 
+-			ehrpwm1: ehrpwm@48302200 {
++
++			eqep1: eqep@0x48302180 {
++				compatible = "ti,am33xx-eqep";
++				reg = <0x48302180 0x80>;
++				interrupt-parent = <&intc>;
++				interrupts = <88>;
++				ti,hwmods = "eqep1";
++				status = "disabled";
++			};
++
++			ehrpwm1: pwm@48302200 {
+ 				compatible = "ti,am33xx-ehrpwm";
+ 				#pwm-cells = <3>;
+ 				reg = <0x48302200 0x80>;
+-				ti,hwmods = "ehrpwm1";
++				clocks = <&ehrpwm1_tbclk>;
++				clock-names = "tbclk";
+ 				status = "disabled";
+ 			};
+ 		};
+@@ -703,15 +852,24 @@
+ 				reg = <0x48304100 0x80>;
+ 				interrupts = <61>;
+ 				interrupt-names = "ecap2";
+-				ti,hwmods = "ecap2";
+ 				status = "disabled";
+ 			};
+ 
+-			ehrpwm2: ehrpwm@48304200 {
++			eqep2: eqep@0x48304180 {
++				compatible = "ti,am33xx-eqep";
++				reg = <0x48304180 0x80>;
++				interrupt-parent = <&intc>;
++				interrupts = <89>;
++				ti,hwmods = "eqep2";
++				status = "disabled";
++			};
++
++			ehrpwm2: pwm@48304200 {
+ 				compatible = "ti,am33xx-ehrpwm";
+ 				#pwm-cells = <3>;
+ 				reg = <0x48304200 0x80>;
+-				ti,hwmods = "ehrpwm2";
++				clocks = <&ehrpwm2_tbclk>;
++				clock-names = "tbclk";
+ 				status = "disabled";
+ 			};
+ 		};
+@@ -776,7 +934,69 @@
+ 
+ 		ocmcram: ocmcram@40300000 {
+ 			compatible = "mmio-sram";
+-			reg = <0x40300000 0x10000>; /* 64k */
++			reg = <0x40300000 0x2000>; /* 8k */
++			map-exec;
++		};
++
++		ocmcram_nocache: ocmcram_nocache@40302000 {
++			compatible = "mmio-sram";
++			reg = <0x40302000 0xe000>; /* 64k - 8k */
++		};
++
++		pruss: pruss@4a300000 {
++			compatible = "ti,am3352-pruss";
++			ti,hwmods = "pruss";
++			reg = <0x4a300000 0x2000>,
++			      <0x4a302000 0x2000>,
++			      <0x4a310000 0x3000>,
++			      <0x4a320000 0x2000>,
++			      <0x4a326000 0x2000>,
++			      <0x4a32e000 0x31c>,
++			      <0x4a332000 0x58>;
++			reg-names = "dram0", "dram1", "shrdram2", "intc", "cfg",
++				    "iep", "mii_rt";
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			pruss_intc: intc@4a320000 {
++				compatible = "ti,am3352-pruss-intc";
++				interrupts = <20 21 22 23 24 25 26 27>;
++				interrupt-names = "host2", "host3", "host4",
++						  "host5", "host6", "host7",
++						  "host8", "host9";
++				interrupt-controller;
++				#interrupt-cells = <1>;
++			};
++
++			pru0: pru0@4a334000 {
++				compatible = "ti,am3352-pru";
++				reg = <0x4a334000 0x2000>,
++				      <0x4a322000 0x400>,
++				      <0x4a322400 0x100>;
++				reg-names = "iram", "control", "debug";
++				mboxes = <&mailbox &mbox_pru0>;
++			};
++
++			pru1: pru1@4a338000 {
++				compatible = "ti,am3352-pru";
++				reg = <0x4a338000 0x2000>,
++				      <0x4a324000 0x400>,
++				      <0x4a324400 0x100>;
++				reg-names = "iram", "control", "debug";
++				mboxes = <&mailbox &mbox_pru1>;
++			};
++
++			pruss_mdio: mdio@4a332400 {
++				compatible = "ti,davinci_mdio";
++				reg = <0x4a332400 0x90>;
++				clocks = <&dpll_core_m4_ck>;
++				clock-names = "fck";
++				bus_freq = <1000000>;
++				#address-cells = <1>;
++				#size-cells = <0>;
++				status = "disabled";
++			};
+ 		};
+ 
+ 		elm: elm@48080000 {
+@@ -819,10 +1039,16 @@
+ 			ti,no-idle-on-init;
+ 			reg = <0x50000000 0x2000>;
+ 			interrupts = <100>;
++			dmas = <&edma 52 0>;
++			dma-names = "rxtx";
+ 			gpmc,num-cs = <7>;
+ 			gpmc,num-waitpins = <2>;
+ 			#address-cells = <2>;
+ 			#size-cells = <1>;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++			gpio-controller;
++			#gpio-cells = <2>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -831,7 +1057,7 @@
+ 			ti,hwmods = "sham";
+ 			reg = <0x53100000 0x200>;
+ 			interrupts = <109>;
+-			dmas = <&edma 36>;
++			dmas = <&edma 36 0>;
+ 			dma-names = "rx";
+ 		};
+ 
+@@ -840,8 +1066,8 @@
+ 			ti,hwmods = "aes";
+ 			reg = <0x53500000 0xa0>;
+ 			interrupts = <103>;
+-			dmas = <&edma 6>,
+-			       <&edma 5>;
++			dmas = <&edma 6 0>,
++			       <&edma 5 0>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -854,8 +1080,8 @@
+ 			interrupts = <80>, <81>;
+ 			interrupt-names = "tx", "rx";
+ 			status = "disabled";
+-			dmas = <&edma 8>,
+-				<&edma 9>;
++			dmas = <&edma 8 2>,
++				<&edma 9 2>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -868,8 +1094,8 @@
+ 			interrupts = <82>, <83>;
+ 			interrupt-names = "tx", "rx";
+ 			status = "disabled";
+-			dmas = <&edma 10>,
+-				<&edma 11>;
++			dmas = <&edma 10 2>,
++				<&edma 11 2>;
+ 			dma-names = "tx", "rx";
+ 		};
+ 
+@@ -879,6 +1105,20 @@
+ 			reg = <0x48310000 0x2000>;
+ 			interrupts = <111>;
+ 		};
++
++		/*
++		 * The SGX is disabled by default because it is an optional
++		 * module and only some AM335x variants contain this module,
++		 * such as AM3358 and AM3357. The status should be overwritten
++		 * as "OK" at the corresponding board.dts.
++		 */
++		sgx: sgx@0x56000000 {
++			compatible = "ti,am3352-sgx530", "img,sgx530";
++			ti,hwmods = "gfx";
++			reg = <0x56000000 0x1000000>;
++			interrupts = <37>;
++			status = "disabled";
++		};
+ 	};
+ };
+ 
+Index: linux-4.4.13/arch/arm/boot/dts/am33xx-overlay-edma-fix.dtsi
+===================================================================
+--- /dev/null
++++ linux-4.4.13/arch/arm/boot/dts/am33xx-overlay-edma-fix.dtsi
+@@ -0,0 +1,25 @@
++/*
++ * Device Tree Source for AM33xx Overlay EDMA fixes
++ *
++ * Copyright (C) 2015 Robert Nelson <robertcnelson@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++&spi0 {
++	status = "okay";
++};
++
++&spi1 {
++	status = "okay";
++};
++
++&mcasp0 {
++	status = "okay";
++};
++
++&mcasp1 {
++	status = "okay";
++};
