Index: lede/target/linux/omap/patches-4.4/0011-nvmem-Add-flag-to-export-NVMEM-to-root-only.patch
===================================================================
--- /dev/null
+++ lede/target/linux/omap/patches-4.4/0011-nvmem-Add-flag-to-export-NVMEM-to-root-only.patch
@@ -0,0 +1,108 @@
+From 811b0d6538b9f26f3eb0f90fe4e6118f2480ec6f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Fri, 26 Feb 2016 20:59:18 +0100
+Subject: [PATCH] nvmem: Add flag to export NVMEM to root only
+
+Legacy AT24, AT25 EEPROMs are exported in sys so that only root can
+read the contents. The EEPROMs may contain sensitive information. Add
+a flag so the provide can indicate that NVMEM should also restrict
+access to root only.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/nvmem/core.c           | 57 ++++++++++++++++++++++++++++++++++++++++--
+ include/linux/nvmem-provider.h |  1 +
+ 2 files changed, 56 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
+index de14fae..b03690b 100644
+--- a/drivers/nvmem/core.c
++++ b/drivers/nvmem/core.c
+@@ -161,6 +161,53 @@ static const struct attribute_group *nvmem_ro_dev_groups[] = {
+ 	NULL,
+ };
+ 
++/* default read/write permissions, root only */
++static struct bin_attribute bin_attr_rw_root_nvmem = {
++	.attr	= {
++		.name	= "nvmem",
++		.mode	= S_IWUSR | S_IRUSR,
++	},
++	.read	= bin_attr_nvmem_read,
++	.write	= bin_attr_nvmem_write,
++};
++
++static struct bin_attribute *nvmem_bin_rw_root_attributes[] = {
++	&bin_attr_rw_root_nvmem,
++	NULL,
++};
++
++static const struct attribute_group nvmem_bin_rw_root_group = {
++	.bin_attrs	= nvmem_bin_rw_root_attributes,
++};
++
++static const struct attribute_group *nvmem_rw_root_dev_groups[] = {
++	&nvmem_bin_rw_root_group,
++	NULL,
++};
++
++/* read only permission, root only */
++static struct bin_attribute bin_attr_ro_root_nvmem = {
++	.attr	= {
++		.name	= "nvmem",
++		.mode	= S_IRUSR,
++	},
++	.read	= bin_attr_nvmem_read,
++};
++
++static struct bin_attribute *nvmem_bin_ro_root_attributes[] = {
++	&bin_attr_ro_root_nvmem,
++	NULL,
++};
++
++static const struct attribute_group nvmem_bin_ro_root_group = {
++	.bin_attrs	= nvmem_bin_ro_root_attributes,
++};
++
++static const struct attribute_group *nvmem_ro_root_dev_groups[] = {
++	&nvmem_bin_ro_root_group,
++	NULL,
++};
++
+ static void nvmem_release(struct device *dev)
+ {
+ 	struct nvmem_device *nvmem = to_nvmem_device(dev);
+@@ -355,8 +402,14 @@ struct nvmem_device *nvmem_register(const struct nvmem_config *config)
+ 	nvmem->read_only = of_property_read_bool(np, "read-only") |
+ 			   config->read_only;
+ 
+-	nvmem->dev.groups = nvmem->read_only ? nvmem_ro_dev_groups :
+-					       nvmem_rw_dev_groups;
++	if (config->root_only)
++		nvmem->dev.groups = nvmem->read_only ?
++			nvmem_ro_root_dev_groups :
++			nvmem_rw_root_dev_groups;
++	else
++		nvmem->dev.groups = nvmem->read_only ?
++			nvmem_ro_dev_groups :
++			nvmem_rw_dev_groups;
+ 
+ 	device_initialize(&nvmem->dev);
+ 
+diff --git a/include/linux/nvmem-provider.h b/include/linux/nvmem-provider.h
+index 0b68caf..d24fefa 100644
+--- a/include/linux/nvmem-provider.h
++++ b/include/linux/nvmem-provider.h
+@@ -23,6 +23,7 @@ struct nvmem_config {
+ 	const struct nvmem_cell_info	*cells;
+ 	int			ncells;
+ 	bool			read_only;
++	bool			root_only;
+ };
+ 
+ #if IS_ENABLED(CONFIG_NVMEM)
+-- 
+2.9.0
+
Index: lede/target/linux/omap/patches-4.4/0012-nvmem-Add-backwards-compatibility-support-for-older-.patch
===================================================================
--- /dev/null
+++ lede/target/linux/omap/patches-4.4/0012-nvmem-Add-backwards-compatibility-support-for-older-.patch
@@ -0,0 +1,189 @@
+From b6c217ab9be6895384cf0b284ace84ad79e5c53b Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Fri, 26 Feb 2016 20:59:19 +0100
+Subject: [PATCH] nvmem: Add backwards compatibility support for older EEPROM
+ drivers.
+
+Older drivers made an 'eeprom' file available in the /sys device
+directory. Have the NVMEM core provide this to retain backwards
+compatibility.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/nvmem/core.c           | 84 ++++++++++++++++++++++++++++++++++++++----
+ include/linux/nvmem-provider.h |  4 +-
+ 2 files changed, 79 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
+index b03690b..0de3d87 100644
+--- a/drivers/nvmem/core.c
++++ b/drivers/nvmem/core.c
+@@ -38,8 +38,13 @@ struct nvmem_device {
+ 	int			users;
+ 	size_t			size;
+ 	bool			read_only;
++	int			flags;
++	struct bin_attribute	eeprom;
++	struct device		*base_dev;
+ };
+ 
++#define FLAG_COMPAT		BIT(0)
++
+ struct nvmem_cell {
+ 	const char		*name;
+ 	int			offset;
+@@ -56,16 +61,26 @@ static DEFINE_IDA(nvmem_ida);
+ static LIST_HEAD(nvmem_cells);
+ static DEFINE_MUTEX(nvmem_cells_mutex);
+ 
++#ifdef CONFIG_DEBUG_LOCK_ALLOC
++static struct lock_class_key eeprom_lock_key;
++#endif
++
+ #define to_nvmem_device(d) container_of(d, struct nvmem_device, dev)
+ 
+ static ssize_t bin_attr_nvmem_read(struct file *filp, struct kobject *kobj,
+ 				    struct bin_attribute *attr,
+ 				    char *buf, loff_t pos, size_t count)
+ {
+-	struct device *dev = container_of(kobj, struct device, kobj);
+-	struct nvmem_device *nvmem = to_nvmem_device(dev);
++	struct device *dev;
++	struct nvmem_device *nvmem;
+ 	int rc;
+ 
++	if (attr->private)
++		dev = attr->private;
++	else
++		dev = container_of(kobj, struct device, kobj);
++	nvmem = to_nvmem_device(dev);
++
+ 	/* Stop the user from reading */
+ 	if (pos >= nvmem->size)
+ 		return 0;
+@@ -90,10 +105,16 @@ static ssize_t bin_attr_nvmem_write(struct file *filp, struct kobject *kobj,
+ 				     struct bin_attribute *attr,
+ 				     char *buf, loff_t pos, size_t count)
+ {
+-	struct device *dev = container_of(kobj, struct device, kobj);
+-	struct nvmem_device *nvmem = to_nvmem_device(dev);
++	struct device *dev;
++	struct nvmem_device *nvmem;
+ 	int rc;
+ 
++	if (attr->private)
++		dev = attr->private;
++	else
++		dev = container_of(kobj, struct device, kobj);
++	nvmem = to_nvmem_device(dev);
++
+ 	/* Stop the user from writing */
+ 	if (pos >= nvmem->size)
+ 		return 0;
+@@ -349,6 +370,43 @@ err:
+ 	return rval;
+ }
+ 
++/*
++ * nvmem_setup_compat() - Create an additional binary entry in
++ * drivers sys directory, to be backwards compatible with the older
++ * drivers/misc/eeprom drivers.
++ */
++static int nvmem_setup_compat(struct nvmem_device *nvmem,
++			      const struct nvmem_config *config)
++{
++	int rval;
++
++	if (!config->base_dev)
++		return -EINVAL;
++
++	if (nvmem->read_only)
++		nvmem->eeprom = bin_attr_ro_root_nvmem;
++	else
++		nvmem->eeprom = bin_attr_rw_root_nvmem;
++	nvmem->eeprom.attr.name = "eeprom";
++	nvmem->eeprom.size = nvmem->size;
++#ifdef CONFIG_DEBUG_LOCK_ALLOC
++	nvmem->eeprom.attr.key = &eeprom_lock_key;
++#endif
++	nvmem->eeprom.private = &nvmem->dev;
++	nvmem->base_dev = config->base_dev;
++
++	rval = device_create_bin_file(nvmem->base_dev, &nvmem->eeprom);
++	if (rval) {
++		dev_err(&nvmem->dev,
++			"Failed to create eeprom binary file %d\n", rval);
++		return rval;
++	}
++
++	nvmem->flags |= FLAG_COMPAT;
++
++	return 0;
++}
++
+ /**
+  * nvmem_register() - Register a nvmem device for given nvmem_config.
+  * Also creates an binary entry in /sys/bus/nvmem/devices/dev-name/nvmem
+@@ -416,16 +474,23 @@ struct nvmem_device *nvmem_register(const struct nvmem_config *config)
+ 	dev_dbg(&nvmem->dev, "Registering nvmem device %s\n", config->name);
+ 
+ 	rval = device_add(&nvmem->dev);
+-	if (rval) {
+-		ida_simple_remove(&nvmem_ida, nvmem->id);
+-		kfree(nvmem);
+-		return ERR_PTR(rval);
++	if (rval)
++		goto out;
++
++	if (config->compat) {
++		rval = nvmem_setup_compat(nvmem, config);
++		if (rval)
++			goto out;
+ 	}
+ 
+ 	if (config->cells)
+ 		nvmem_add_cells(nvmem, config);
+ 
+ 	return nvmem;
++out:
++	ida_simple_remove(&nvmem_ida, nvmem->id);
++	kfree(nvmem);
++	return ERR_PTR(rval);
+ }
+ EXPORT_SYMBOL_GPL(nvmem_register);
+ 
+@@ -445,6 +510,9 @@ int nvmem_unregister(struct nvmem_device *nvmem)
+ 	}
+ 	mutex_unlock(&nvmem_mutex);
+ 
++	if (nvmem->flags & FLAG_COMPAT)
++		device_remove_bin_file(nvmem->base_dev, &nvmem->eeprom);
++
+ 	nvmem_device_remove_all_cells(nvmem);
+ 	device_del(&nvmem->dev);
+ 
+diff --git a/include/linux/nvmem-provider.h b/include/linux/nvmem-provider.h
+index d24fefa..a4fcc90 100644
+--- a/include/linux/nvmem-provider.h
++++ b/include/linux/nvmem-provider.h
+@@ -24,6 +24,9 @@ struct nvmem_config {
+ 	int			ncells;
+ 	bool			read_only;
+ 	bool			root_only;
++	/* To be only used by old driver/misc/eeprom drivers */
++	bool			compat;
++	struct device		*base_dev;
+ };
+ 
+ #if IS_ENABLED(CONFIG_NVMEM)
+@@ -44,5 +47,4 @@ static inline int nvmem_unregister(struct nvmem_device *nvmem)
+ }
+ 
+ #endif /* CONFIG_NVMEM */
+-
+ #endif  /* ifndef _LINUX_NVMEM_PROVIDER_H */
+-- 
+2.9.0
+
Index: lede/target/linux/omap/patches-4.4/0013-nvmem-core-remove-regmap-dependency.patch
===================================================================
--- /dev/null
+++ lede/target/linux/omap/patches-4.4/0013-nvmem-core-remove-regmap-dependency.patch
@@ -0,0 +1,277 @@
+From 795ddd18d38f9762fbfefceab9aa16caef0cf431 Mon Sep 17 00:00:00 2001
+From: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Date: Sun, 24 Apr 2016 20:28:05 +0100
+Subject: [PATCH] nvmem: core: remove regmap dependency
+
+nvmem uses regmap_raw_read/write apis to read/write data from providers,
+regmap raw apis stopped working with recent kernels which removed raw
+accessors on mmio bus. This resulted in broken nvmem for providers
+which are based on regmap mmio bus. This issue can be fixed temporarly
+by moving to other regmap apis, but we might hit same issue in future.
+Moving to interfaces based on read/write callbacks from providers would
+be more robust.
+
+This patch removes regmap dependency from nvmem and introduces
+read/write callbacks from the providers.
+
+Without this patch nvmem providers like qfprom based on regmap mmio
+bus would not work.
+
+Reported-by: Rajendra Nayak <rjendra@qti.qualcomm.com>
+Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/nvmem/Kconfig          |  1 -
+ drivers/nvmem/core.c           | 67 +++++++++++++++++++++++++-----------------
+ include/linux/nvmem-provider.h | 10 +++++++
+ 3 files changed, 50 insertions(+), 28 deletions(-)
+
+diff --git a/drivers/nvmem/Kconfig b/drivers/nvmem/Kconfig
+index 9c0c59d..15c58a5 100644
+--- a/drivers/nvmem/Kconfig
++++ b/drivers/nvmem/Kconfig
+@@ -1,6 +1,5 @@
+ menuconfig NVMEM
+ 	tristate "NVMEM Support"
+-	select REGMAP
+ 	help
+ 	  Support for NVMEM(Non Volatile Memory) devices like EEPROM, EFUSES...
+ 
+diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
+index 0de3d87..bb4ea12 100644
+--- a/drivers/nvmem/core.c
++++ b/drivers/nvmem/core.c
+@@ -23,12 +23,10 @@
+ #include <linux/nvmem-consumer.h>
+ #include <linux/nvmem-provider.h>
+ #include <linux/of.h>
+-#include <linux/regmap.h>
+ #include <linux/slab.h>
+ 
+ struct nvmem_device {
+ 	const char		*name;
+-	struct regmap		*regmap;
+ 	struct module		*owner;
+ 	struct device		dev;
+ 	int			stride;
+@@ -41,6 +39,9 @@ struct nvmem_device {
+ 	int			flags;
+ 	struct bin_attribute	eeprom;
+ 	struct device		*base_dev;
++	nvmem_reg_read_t	reg_read;
++	nvmem_reg_write_t	reg_write;
++	void *priv;
+ };
+ 
+ #define FLAG_COMPAT		BIT(0)
+@@ -66,6 +67,23 @@ static struct lock_class_key eeprom_lock_key;
+ #endif
+ 
+ #define to_nvmem_device(d) container_of(d, struct nvmem_device, dev)
++static int nvmem_reg_read(struct nvmem_device *nvmem, unsigned int offset,
++			  void *val, size_t bytes)
++{
++	if (nvmem->reg_read)
++		return nvmem->reg_read(nvmem->priv, offset, val, bytes);
++
++	return -EINVAL;
++}
++
++static int nvmem_reg_write(struct nvmem_device *nvmem, unsigned int offset,
++			   void *val, size_t bytes)
++{
++	if (nvmem->reg_write)
++		return nvmem->reg_write(nvmem->priv, offset, val, bytes);
++
++	return -EINVAL;
++}
+ 
+ static ssize_t bin_attr_nvmem_read(struct file *filp, struct kobject *kobj,
+ 				    struct bin_attribute *attr,
+@@ -93,7 +111,7 @@ static ssize_t bin_attr_nvmem_read(struct file *filp, struct kobject *kobj,
+ 
+ 	count = round_down(count, nvmem->word_size);
+ 
+-	rc = regmap_raw_read(nvmem->regmap, pos, buf, count);
++	rc = nvmem_reg_read(nvmem, pos, buf, count);
+ 
+ 	if (IS_ERR_VALUE(rc))
+ 		return rc;
+@@ -127,7 +145,7 @@ static ssize_t bin_attr_nvmem_write(struct file *filp, struct kobject *kobj,
+ 
+ 	count = round_down(count, nvmem->word_size);
+ 
+-	rc = regmap_raw_write(nvmem->regmap, pos, buf, count);
++	rc = nvmem_reg_write(nvmem, pos, buf, count);
+ 
+ 	if (IS_ERR_VALUE(rc))
+ 		return rc;
+@@ -421,18 +439,11 @@ struct nvmem_device *nvmem_register(const struct nvmem_config *config)
+ {
+ 	struct nvmem_device *nvmem;
+ 	struct device_node *np;
+-	struct regmap *rm;
+ 	int rval;
+ 
+ 	if (!config->dev)
+ 		return ERR_PTR(-EINVAL);
+ 
+-	rm = dev_get_regmap(config->dev, NULL);
+-	if (!rm) {
+-		dev_err(config->dev, "Regmap not found\n");
+-		return ERR_PTR(-EINVAL);
+-	}
+-
+ 	nvmem = kzalloc(sizeof(*nvmem), GFP_KERNEL);
+ 	if (!nvmem)
+ 		return ERR_PTR(-ENOMEM);
+@@ -444,14 +455,16 @@ struct nvmem_device *nvmem_register(const struct nvmem_config *config)
+ 	}
+ 
+ 	nvmem->id = rval;
+-	nvmem->regmap = rm;
+ 	nvmem->owner = config->owner;
+-	nvmem->stride = regmap_get_reg_stride(rm);
+-	nvmem->word_size = regmap_get_val_bytes(rm);
+-	nvmem->size = regmap_get_max_register(rm) + nvmem->stride;
++	nvmem->stride = config->stride;
++	nvmem->word_size = config->word_size;
++	nvmem->size = config->size;
+ 	nvmem->dev.type = &nvmem_provider_type;
+ 	nvmem->dev.bus = &nvmem_bus_type;
+ 	nvmem->dev.parent = config->dev;
++	nvmem->priv = config->priv;
++	nvmem->reg_read = config->reg_read;
++	nvmem->reg_write = config->reg_write;
+ 	np = config->dev->of_node;
+ 	nvmem->dev.of_node = np;
+ 	dev_set_name(&nvmem->dev, "%s%d",
+@@ -948,7 +961,7 @@ static int __nvmem_cell_read(struct nvmem_device *nvmem,
+ {
+ 	int rc;
+ 
+-	rc = regmap_raw_read(nvmem->regmap, cell->offset, buf, cell->bytes);
++	rc = nvmem_reg_read(nvmem, cell->offset, buf, cell->bytes);
+ 
+ 	if (IS_ERR_VALUE(rc))
+ 		return rc;
+@@ -977,7 +990,7 @@ void *nvmem_cell_read(struct nvmem_cell *cell, size_t *len)
+ 	u8 *buf;
+ 	int rc;
+ 
+-	if (!nvmem || !nvmem->regmap)
++	if (!nvmem)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	buf = kzalloc(cell->bytes, GFP_KERNEL);
+@@ -1014,7 +1027,7 @@ static inline void *nvmem_cell_prepare_write_buffer(struct nvmem_cell *cell,
+ 		*b <<= bit_offset;
+ 
+ 		/* setup the first byte with lsb bits from nvmem */
+-		rc = regmap_raw_read(nvmem->regmap, cell->offset, &v, 1);
++		rc = nvmem_reg_read(nvmem, cell->offset, &v, 1);
+ 		*b++ |= GENMASK(bit_offset - 1, 0) & v;
+ 
+ 		/* setup rest of the byte if any */
+@@ -1031,7 +1044,7 @@ static inline void *nvmem_cell_prepare_write_buffer(struct nvmem_cell *cell,
+ 	/* if it's not end on byte boundary */
+ 	if ((nbits + bit_offset) % BITS_PER_BYTE) {
+ 		/* setup the last byte with msb bits from nvmem */
+-		rc = regmap_raw_read(nvmem->regmap,
++		rc = nvmem_reg_read(nvmem,
+ 				    cell->offset + cell->bytes - 1, &v, 1);
+ 		*p |= GENMASK(7, (nbits + bit_offset) % BITS_PER_BYTE) & v;
+ 
+@@ -1054,7 +1067,7 @@ int nvmem_cell_write(struct nvmem_cell *cell, void *buf, size_t len)
+ 	struct nvmem_device *nvmem = cell->nvmem;
+ 	int rc;
+ 
+-	if (!nvmem || !nvmem->regmap || nvmem->read_only ||
++	if (!nvmem || nvmem->read_only ||
+ 	    (cell->bit_offset == 0 && len != cell->bytes))
+ 		return -EINVAL;
+ 
+@@ -1064,7 +1077,7 @@ int nvmem_cell_write(struct nvmem_cell *cell, void *buf, size_t len)
+ 			return PTR_ERR(buf);
+ 	}
+ 
+-	rc = regmap_raw_write(nvmem->regmap, cell->offset, buf, cell->bytes);
++	rc = nvmem_reg_write(nvmem, cell->offset, buf, cell->bytes);
+ 
+ 	/* free the tmp buffer */
+ 	if (cell->bit_offset || cell->nbits)
+@@ -1094,7 +1107,7 @@ ssize_t nvmem_device_cell_read(struct nvmem_device *nvmem,
+ 	int rc;
+ 	ssize_t len;
+ 
+-	if (!nvmem || !nvmem->regmap)
++	if (!nvmem)
+ 		return -EINVAL;
+ 
+ 	rc = nvmem_cell_info_to_nvmem_cell(nvmem, info, &cell);
+@@ -1124,7 +1137,7 @@ int nvmem_device_cell_write(struct nvmem_device *nvmem,
+ 	struct nvmem_cell cell;
+ 	int rc;
+ 
+-	if (!nvmem || !nvmem->regmap)
++	if (!nvmem)
+ 		return -EINVAL;
+ 
+ 	rc = nvmem_cell_info_to_nvmem_cell(nvmem, info, &cell);
+@@ -1152,10 +1165,10 @@ int nvmem_device_read(struct nvmem_device *nvmem,
+ {
+ 	int rc;
+ 
+-	if (!nvmem || !nvmem->regmap)
++	if (!nvmem)
+ 		return -EINVAL;
+ 
+-	rc = regmap_raw_read(nvmem->regmap, offset, buf, bytes);
++	rc = nvmem_reg_read(nvmem, offset, buf, bytes);
+ 
+ 	if (IS_ERR_VALUE(rc))
+ 		return rc;
+@@ -1180,10 +1193,10 @@ int nvmem_device_write(struct nvmem_device *nvmem,
+ {
+ 	int rc;
+ 
+-	if (!nvmem || !nvmem->regmap)
++	if (!nvmem)
+ 		return -EINVAL;
+ 
+-	rc = regmap_raw_write(nvmem->regmap, offset, buf, bytes);
++	rc = nvmem_reg_write(nvmem, offset, buf, bytes);
+ 
+ 	if (IS_ERR_VALUE(rc))
+ 		return rc;
+diff --git a/include/linux/nvmem-provider.h b/include/linux/nvmem-provider.h
+index a4fcc90..cd93416 100644
+--- a/include/linux/nvmem-provider.h
++++ b/include/linux/nvmem-provider.h
+@@ -14,6 +14,10 @@
+ 
+ struct nvmem_device;
+ struct nvmem_cell_info;
++typedef int (*nvmem_reg_read_t)(void *priv, unsigned int offset,
++				void *val, size_t bytes);
++typedef int (*nvmem_reg_write_t)(void *priv, unsigned int offset,
++				 void *val, size_t bytes);
+ 
+ struct nvmem_config {
+ 	struct device		*dev;
+@@ -24,6 +28,12 @@ struct nvmem_config {
+ 	int			ncells;
+ 	bool			read_only;
+ 	bool			root_only;
++	nvmem_reg_read_t	reg_read;
++	nvmem_reg_write_t	reg_write;
++	int	size;
++	int	word_size;
++	int	stride;
++	void	*priv;
+ 	/* To be only used by old driver/misc/eeprom drivers */
+ 	bool			compat;
+ 	struct device		*base_dev;
+-- 
+2.9.0
+
